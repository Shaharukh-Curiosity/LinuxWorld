'use strict';

Object.defineProperty(exports, "__esModule", { value: true });

const picomatch = require('picomatch');
const normalizePath = require('normalize-path');

/**
 * @typedef {(testString: string) => boolean} AnymatchFn
 * @typedef {string|RegExp|AnymatchFn} AnymatchPattern
 * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher
 */
const BANG = '!';
<<<<<<< HEAD
=======
const DEFAULT_OPTIONS = {returnIndex: false};
>>>>>>> dc7ca8caa9759d4a9def25682707f917f8e9a75e
const arrify = (item) => Array.isArray(item) ? item : [item];

/**
 * @param {AnymatchPattern} matcher
<<<<<<< HEAD
 * @returns {AnymatchFn}
 */
const createPattern = (matcher) => {
=======
 * @param {object} options
 * @returns {AnymatchFn}
 */
const createPattern = (matcher, options) => {
>>>>>>> dc7ca8caa9759d4a9def25682707f917f8e9a75e
  if (typeof matcher === 'function') {
    return matcher;
  }
  if (typeof matcher === 'string') {
<<<<<<< HEAD
    const glob = picomatch(matcher);
=======
    const glob = picomatch(matcher, options);
>>>>>>> dc7ca8caa9759d4a9def25682707f917f8e9a75e
    return (string) => matcher === string || glob(string);
  }
  if (matcher instanceof RegExp) {
    return (string) => matcher.test(string);
  }
  return (string) => false;
};

/**
 * @param {Array<Function>} patterns
<<<<<<< HEAD
 * @param {Array<Function>} negatedGlobs
 * @param {String|Array} path
 * @param {Boolean} returnIndex
 * @returns {boolean|number}
 */
const matchPatterns = (patterns, negatedGlobs, path, returnIndex) => {
  const additionalArgs = Array.isArray(path);
  const upath = normalizePath(additionalArgs ? path[0] : path);
  for (let index = 0; index < negatedGlobs.length; index++) {
    const nglob = negatedGlobs[index];
    if (nglob(upath)) {
      return returnIndex ? -1 : false;
    }
  }
  const args = additionalArgs && [upath].concat(path.slice(1));
  for (let index = 0; index < patterns.length; index++) {
    const pattern = patterns[index];
    if (additionalArgs ? pattern(...args) : pattern(upath)) {
=======
 * @param {Array<Function>} negPatterns
 * @param {String|Array} args
 * @param {Boolean} returnIndex
 * @returns {boolean|number}
 */
const matchPatterns = (patterns, negPatterns, args, returnIndex) => {
  const isList = Array.isArray(args);
  const _path = isList ? args[0] : args;
  if (!isList && typeof _path !== 'string') {
    throw new TypeError('anymatch: second argument must be a string: got ' +
      Object.prototype.toString.call(_path))
  }
  const path = normalizePath(_path);

  for (let index = 0; index < negPatterns.length; index++) {
    const nglob = negPatterns[index];
    if (nglob(path)) {
      return returnIndex ? -1 : false;
    }
  }

  const applied = isList && [path].concat(args.slice(1));
  for (let index = 0; index < patterns.length; index++) {
    const pattern = patterns[index];
    if (isList ? pattern(...applied) : pattern(path)) {
>>>>>>> dc7ca8caa9759d4a9def25682707f917f8e9a75e
      return returnIndex ? index : true;
    }
  }

  return returnIndex ? -1 : false;
};

/**
 * @param {AnymatchMatcher} matchers
 * @param {Array|string} testString
<<<<<<< HEAD
 * @param {boolean=} returnIndex
 * @returns {boolean|number|Function}
 */
const anymatch = (matchers, testString, returnIndex = false) => {
  if (matchers == null) {
    throw new TypeError('anymatch: specify first argument');
  }
=======
 * @param {object} options
 * @returns {boolean|number|Function}
 */
const anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {
  if (matchers == null) {
    throw new TypeError('anymatch: specify first argument');
  }
  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;
  const returnIndex = opts.returnIndex || false;

>>>>>>> dc7ca8caa9759d4a9def25682707f917f8e9a75e
  // Early cache for matchers.
  const mtchers = arrify(matchers);
  const negatedGlobs = mtchers
    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)
    .map(item => item.slice(1))
<<<<<<< HEAD
    .map(item => picomatch(item));
  const patterns = mtchers.map(createPattern);
=======
    .map(item => picomatch(item, opts));
  const patterns = mtchers.map(matcher => createPattern(matcher, opts));
>>>>>>> dc7ca8caa9759d4a9def25682707f917f8e9a75e

  if (testString == null) {
    return (testString, ri = false) => {
      const returnIndex = typeof ri === 'boolean' ? ri : false;
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    }
  }
<<<<<<< HEAD
  if (!Array.isArray(testString) && typeof testString !== 'string') {
    throw new TypeError('anymatch: second argument must be a string: got ' +
      Object.prototype.toString.call(testString))
  }
=======
>>>>>>> dc7ca8caa9759d4a9def25682707f917f8e9a75e

  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
};

anymatch.default = anymatch;
module.exports = anymatch;
